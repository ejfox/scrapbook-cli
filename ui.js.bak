import blessed from "blessed";
import contrib from "blessed-contrib";
import { execSync } from "child_process";
import { format } from "date-fns";
import { SCRAP_TYPE_SYMBOLS, VIEW_HEADERS, ALL_HEADERS } from "./constants.js";
import {
  formatTableData,
  reloadBookmarks,
  searchBookmarks,
  formatRelationships,
  formatLocation,
  formatFinancialAnalysis,
  formatTags,
  formatSummary,
  stripMarkdown
} from "./data.js";
import chalk from "chalk";

let currentSummaryInterval;
let fullScreenSummaryInterval;
let fullScreenSummaryScrollOffset = 0;
const fullScreenSummaryLinesPerPage = 20;

function stopCurrentAnimation() {
  if (currentSummaryInterval) {
    clearInterval(currentSummaryInterval);
    currentSummaryInterval = null;
  }
}

export function viewSummary(
  index,
  currentBookmarks,
  summaryBox,
  alertBox,
  miniMap,
  screen
) {
  stopCurrentAnimation();

  const bookmark = currentBookmarks[index];
  if (!bookmark) {
    summaryBox.setContent("No bookmark found for this index.");
    screen.render();
    return;
  }

  // Filter out embedding fields and other technical fields from display
  const displayHeaders = ALL_HEADERS.filter(header =>
    !header.includes('embedding') &&
    header !== 'id' &&
    header !== 'processing_instance_id' &&
    header !== 'processing_started_at'
  );

  const summary = displayHeaders.map((header) => {
    const value = bookmark[header];
    let formattedValue;

    if (!value) {
      formattedValue = "";
    } else if (header === "relationships") {
      formattedValue = formatRelationships(value);
    } else if (header === "location") {
      formattedValue = formatLocation(value);
    } else if (header === "financial_analysis") {
      formattedValue = formatFinancialAnalysis(value);
    } else if (header === "tags") {
      formattedValue = formatTags(value);
    } else if (header === "summary") {
      formattedValue = value; // Keep full summary in detail view
    } else if (header === "created_at" || header === "updated_at") {
      formattedValue = format(new Date(value), "yyyy-MM-dd HH:mm");
    } else if (typeof value === "string") {
      formattedValue = value;
    } else {
      formattedValue = JSON.stringify(value, null, 2);
    }

    return formattedValue ? `${header}: ${formattedValue}` : null;
  }).filter(Boolean).join("\n\n");

  let charIndex = 0;
  const animDuration = 10;
  const lettersAtATime = 8;

  alertBox.setContent(JSON.stringify(bookmark.metadata, null, 2));

  updateMiniMap(miniMap, bookmark);

  const typeOutSummary = () => {
    if (charIndex < summary.length) {
      const endIndex = Math.min(charIndex + lettersAtATime, summary.length);
      summaryBox.setContent(summary.slice(0, endIndex));
      screen.render();
      charIndex += lettersAtATime;
    } else {
      clearInterval(currentSummaryInterval);
    }
  };

  currentSummaryInterval = setInterval(typeOutSummary, animDuration);
}

export function updateSummary(
  index,
  currentBookmarks,
  summaryBox,
  alertBox,
  miniMap,
  screen
) {
  stopCurrentAnimation();
  const validIndex = Math.max(0, Math.min(index, currentBookmarks.length - 1));
  if (validIndex < currentBookmarks.length && currentBookmarks[validIndex]) {
    viewSummary(
      validIndex,
      currentBookmarks,
      summaryBox,
      alertBox,
      miniMap,
      screen
    );
  } else {
    summaryBox.setContent("No bookmark selected or data error.");
    screen.render();
  }
}

export function updateMiniMap(miniMap, bookmark) {
  miniMap.clearMarkers();
  if (bookmark.metadata.latitude && bookmark.metadata.longitude) {
    miniMap.addMarker({
      lat: bookmark.metadata.latitude,
      lon: bookmark.metadata.longitude,
      color: "red",
      char: "X",
    });
    miniMap.show();
  } else {
    miniMap.hide();
  }
}

export function createUI(bookmarks) {
  const screen = blessed.screen({
    smartCSR: true,
    title: "ejfox.com/scrapbook CLI",
    dockBorders: true,
    fullUnicode: true,
    autoPadding: true,
  });
  const grid = new contrib.grid({ rows: 12, cols: 12, screen: screen });
  const table = createTable(grid);
  const summaryBox = createSummaryBox(grid);
  const alertBox = createAlertBox(grid);
  const miniMap = createMiniMap(grid);
  const searchQueryBox = createSearchQueryBox(screen);
  const fullScreenSummaryBox = createFullScreenSummaryBox(screen);

  function updateDisplay(bookmarksToDisplay) {
    const tableData = formatTableData(bookmarksToDisplay);
    const coloredTableData = {
      headers: tableData.headers,
      data: tableData.data.map((row) => {
        if (!Array.isArray(row)) return [];
        return row.map((cell, index) => {
          const safeCell = (cell ?? "").toString();
          return index === 1 ? chalk.green(safeCell) : safeCell;
        });
      }),
    };

    table.setData(coloredTableData);
    alertBox.setContent(`${bookmarksToDisplay.length} bookmarks`);
    screen.render();
  }

  updateDisplay(bookmarks);

  return {
    table,
    screen,
    summaryBox,
    alertBox,
    miniMap,
    searchQueryBox,
    fullScreenSummaryBox,
    updateDisplay,
  };
}

export function setupKeyboardShortcuts(
  screen,
  table,
  summaryBox,
  alertBox,
  miniMap,
  searchQueryBox,
  fullScreenSummaryBox,
  bookmarks,
  updateDisplay
) {
  screen.key(["q", "C-c"], () => process.exit(0));

  screen.key(["h"], () => {
    summaryBox.setContent(displayHelp());
    screen.render();
  });

  screen.key(["?"], () => {
    // Show help in full-screen overlay
    fullScreenSummaryBox.setContent(displayHelp());
    fullScreenSummaryBox.show();
    screen.render();
  });

  screen.key(["f"], () => {
    // Show force layout view of relationships for current bookmark
    const currentIndex = table.rows.selected || 0;
    const currentBookmark = bookmarks[currentIndex];
    if (currentBookmark) {
      createForceLayoutView([currentBookmark], screen, currentBookmark);
    } else {
      alertBox.setContent("No bookmark selected for force layout view");
      screen.render();
    }
  });

  screen.key(["escape"], () => {
    if (fullScreenSummaryBox.visible) {
      fullScreenSummaryBox.hide();
      screen.render();
    }
    stopCurrentAnimation();
    searchQueryBox.content = "";
    searchQueryBox.hide();
    reloadBookmarks(updateDisplay).then((newBookmarks) => {
      bookmarks.length = 0;
      bookmarks.push(...newBookmarks);
    });
  });

  screen.key(["j", "down"], () => {
    const nextIndex = table.rows.selected + 1;
    if (nextIndex < bookmarks.length) {
      updateSummary(
        nextIndex,
        bookmarks,
        summaryBox,
        alertBox,
        miniMap,
        screen
      );
    }
    screen.render();
  });

  screen.key(["k", "up"], () => {
    const prevIndex = table.rows.selected - 1;
    if (prevIndex >= 0) {
      updateSummary(
        prevIndex,
        bookmarks,
        summaryBox,
        alertBox,
        miniMap,
        screen
      );
    }
    screen.render();
  });

  screen.key(["space"], () => {
    const selected = table.rows.selected;
    if (selected >= 0 && selected < bookmarks.length) {
      updateSummary(selected, bookmarks, summaryBox, alertBox, miniMap, screen);
      const bookmark = bookmarks[selected];
      const url = bookmark.url;
      try {
        execSync(`open ${url}`);
        alertBox.setContent("Opening in browser: " + url);
      } catch (error) {
        alertBox.setContent("Error opening in browser: " + error);
      }
      setTimeout(() => {
        alertBox.setContent("");
        screen.render();
      }, 5000);
      screen.render();
    }
  });

  screen.key(["pageup"], () => {
    summaryBox.scroll(-(summaryBox.height || 10));
    summaryBox.screen.render();
  });

  screen.key(["pagedown"], () => {
    table.rows.select(Math.min(bookmarks.length - 1, table.rows.selected + 24));
    screen.render();
  });

  screen.key(["right"], () => {
    const selected = table.rows.selected;
    if (selected >= 0 && selected < bookmarks.length) {
      const bookmark = bookmarks[selected];
      const href = bookmark.public_url;
      try {
        execSync(`echo ${href} | pbcopy`);
        alertBox.setContent("Copied to clipboard: " + href);
      } catch (error) {
        alertBox.setContent("Error copying to clipboard: " + error);
      }
      setTimeout(() => {
        alertBox.setContent("");
        screen.render();
      }, 5000);
      screen.render();
    }
  });

  screen.key(["s", "/"], () => {
    showSearchBox(screen, alertBox, searchQueryBox, updateDisplay, bookmarks);
  });

  screen.key(["z"], () => {
    toggleFullScreenSummary(
      fullScreenSummaryBox,
      bookmarks,
      table.rows.selected
    );
  });

  screen.key(["v"], () => {
    const selectedIndex = table.rows.selected;
    if (selectedIndex >= 0 && selectedIndex < bookmarks.length) {
      const selectedScrap = bookmarks[selectedIndex];
      showRelationshipView(screen, selectedScrap, bookmarks);
    }
  });

  screen.key(["left"], () => {
    const selected = table.rows.selected;
    if (selected >= 0 && selected < bookmarks.length) {
      const bookmark = bookmarks[selected];
      const public_url = bookmark.public_url;
      try {
        execSync(`echo ${public_url} | pbcopy`);
        alertBox.setContent("Copied to clipboard: " + public_url);
      } catch (error) {
        alertBox.setContent("Error copying to clipboard: " + error);
      }
      setTimeout(() => {
        alertBox.setContent("");
        screen.render();
      }, 5000);
      screen.render();
    }
  });

  screen.key(["r"], async () => {
    alertBox.setContent("Refreshing bookmarks...");
    screen.render();
    const newBookmarks = await reloadBookmarks(updateDisplay);
    bookmarks.length = 0;
    bookmarks.push(...newBookmarks);
    alertBox.setContent(`Refreshed ${newBookmarks.length} bookmarks`);
    screen.render();
    setTimeout(() => {
      alertBox.setContent("");
      screen.render();
    }, 3000);
  });
}

function createTable(grid) {
  // Ensure we have a valid terminal width, default to 80 if not available
  const terminalWidth = process.stdout.columns || 80;
  const totalWidth = Math.max(50, terminalWidth - 4); // Account for borders, minimum 50

  // Calculate proportional widths
  const dateWidth = Math.floor(totalWidth * 0.15); // 15% for date
  const sourceWidth = Math.floor(totalWidth * 0.15); // 15% for source
  const contentWidth = totalWidth - dateWidth - sourceWidth; // Rest for content

  return grid.set(0, 0, 12, 8, contrib.table, {
    keys: true,
    label: "Bookmarks",
    columnWidth: [
      Math.max(10, dateWidth), // Min 10 chars for date
      Math.max(8, sourceWidth), // Min 8 chars for source
      Math.max(20, contentWidth), // Min 20 chars for content
    ],
    vi: true,
    style: {
      header: {
        bold: true,
        align: "left",
      },
      cell: {
        selected: {
          bg: "green",
          fg: "black",
        },
      },
    },
  });
}

function createSummaryBox(grid) {
  return grid.set(0, 8, 6, 4, blessed.box, {
    label: "Summary (z to zoom)",
    content:
      "Welcome to scrapbook CLI\n\n" +
      "NAVIGATE : ↑↓\n" +
      "OPEN     : SPACE\n" +
      "SEARCH   : s\n" +
      "ZOOM     : z\n" +
      "REFRESH  : r\n" +
      "QUIT     : q",
    padding: 1,
    border: "line",
  });
}

function createAlertBox(grid) {
  return grid.set(10, 8, 2, 4, blessed.box, {
    content: "",
    padding: 0,
    border: { type: "line" },
    style: {
      focus: { border: { fg: "yellow" } },
    },
  });
}

function createMiniMap(grid) {
  return grid.set(6, 8, 4, 4, contrib.map, {
    label: "Location",
    style: {
      shapeColor: "cyan",
    },
  });
}

function createSearchQueryBox(screen) {
  const box = blessed.box({
    parent: screen,
    top: "90%",
    left: "2%",
    height: 3,
    width: 20,
    content: "",
    padding: 1,
    style: {
      bg: "red",
      fg: "white",
    },
  });
  box.hide();
  return box;
}

function createFullScreenSummaryBox(screen) {
  const box = blessed.box({
    parent: screen,
    top: "center",
    left: "center",
    width: "90%",
    height: "90%",
    content: "",
    tags: true,
    border: "line",
    keys: true,
    vi: true,
    scrollable: true,
    alwaysScroll: true,
    scrollbar: {
      ch: "█",
      track: {
        bg: "black",
      },
      style: {
        inverse: true,
      },
    },
    padding: 1,
  });

  box.hide();
  return box;
}

export function displayHelp() {
  return `
Scrapbook CLI v1.0

NAVIGATION
  ↑/↓        Browse entries
  PgUp/PgDn  Jump 24 entries

ACTIONS
  SPACE      Open in browser
  →          Copy public URL
  ←          Copy scrapbook URL
  Z          Expand summary
  S/         Search mode
  V          View relationships
  F          Force layout of current bookmark
  R          Refresh data

VIEWS
  --map      Map view (startup option)

HELP
  H          Help in sidebar
  ?          Full help overlay

SYSTEM
  ESC        Exit current mode
  Q          Quit

Status: Active
`;
}

async function showSearchBox(
  screen,
  alertBox,
  searchQueryBox,
  updateDisplay,
  bookmarks
) {
  const searchBox = blessed.textbox({
    parent: screen,
    top: "center",
    left: "center",
    height: 4,
    width: "50%",
    border: "line",
    style: {
      border: {
        fg: "black",
      },
    },
  });

  searchBox.focus();
  searchBox.setContent("");
  searchBox.readInput();

  searchBox.on("submit", async (text) => {
    if (!text) return;

    try {
      const searchResults = await searchBookmarks(text);
      bookmarks.length = 0;
      bookmarks.push(...searchResults);

      updateDisplay(bookmarks);
      alertBox.setContent(`Found ${searchResults.length} results`);
    } catch (error) {
      alertBox.setContent(error.message);
    }
    screen.render();
    searchBox.destroy();
  });

  screen.render();
}

function showRelationshipView(screen, scrap, bookmarks) {
  const relationshipBox = blessed.box({
    parent: screen,
    top: "center",
    left: "center",
    width: "90%",
    height: "90%",
    border: {
      type: "line",
    },
    style: {
      border: {
        fg: "white",
      },
    },
    label: "Relationship View",
    content: "",
    scrollable: true,
    alwaysScroll: true,
    scrollbar: {
      ch: " ",
      inverse: true,
    },
  });

  if (!scrap.relationships || scrap.relationships.length === 0) {
    relationshipBox.setContent("No relationships found for this scrap.");
    screen.append(relationshipBox);
    relationshipBox.focus();
    screen.render();
    return;
  }

  let content = `Relationships for: ${scrap.scrap_id}\n\n`;
  scrap.relationships.forEach((rel) => {
    content += `${rel.source.name} [${rel.source.type}] --${rel.type}--> ${rel.target.name} [${rel.target.type}]\n`;
  });
  content += "\n\nPress ESC to close";

  relationshipBox.setContent(content);
  relationshipBox.key(["escape"], () => {
    screen.remove(relationshipBox);
    screen.render();
  });

  screen.append(relationshipBox);
  relationshipBox.focus();
  screen.render();
}

export function toggleFullScreenSummary(summaryBox, bookmarks, selectedIndex) {
  if (summaryBox.visible) {
    summaryBox.hide();
    summaryBox.screen.render();
    return;
  }

  const bookmark = bookmarks[selectedIndex];
  if (!bookmark) {
    summaryBox.setContent(chalk.red("No bookmark found for this index."));
    summaryBox.screen.render();
    return;
  }

  let summaryContent = "";
  if (bookmark.summary) {
    const cleanSummary = stripMarkdown(bookmark.summary);
    summaryContent = cleanSummary
      .split("\n")
      .map((line) => `  ⟡ ${line}`) // Unicode bullet for summary lines
      .join("\n");
  }

  const content = Object.entries(bookmark)
    .filter(
      ([key, value]) =>
        value !== null && value !== undefined &&
        key !== "summary" && // Skip summary as we handle it separately
        !key.includes('embedding') && // Hide all embedding fields
        key !== 'id' &&
        key !== 'processing_instance_id' &&
        key !== 'processing_started_at'
    )
    .map(([key, value]) => {
      let displayValue = "";

      if (key === "relationships" && Array.isArray(value)) {
        displayValue =
          "[\n  " +
          value
            .filter((rel) => rel && rel.source && rel.target) // Filter out invalid relationships
            .map((rel) =>
              chalk.green(
                JSON.stringify(
                  {
                    source: rel.source?.name || rel.source,
                    type: rel.type,
                    target: rel.target?.name || rel.target,
                  },
                  null,
                  2
                )
              )
            )
            .join(",\n  ") +
          "\n]";
      } else if (Array.isArray(value)) {
        displayValue =
          "[\n  " +
          value.map((v) => chalk.green(`"${v}"`)).join(",\n  ") +
          "\n]";
      } else if (typeof value === "object") {
        const jsonString = JSON.stringify(value, null, 2);
        displayValue =
          "\n" +
          jsonString
            .split("\n")
            .map((line) => {
              if (line.includes(":")) {
                const [k, v] = line.split(/:(.*)/);
                return k + ":" + chalk.green(v || "");
              }
              return line;
            })
            .join("\n");
      } else if (key === "url" || key === "public_url") {
        displayValue = chalk.green(value.toString());
      } else if (key === "content" || key === "title") {
        // Strip markdown from content and title fields
        displayValue = stripMarkdown(value.toString());
      } else {
        displayValue = value.toString();
      }

      // Add different Unicode markers for different types of fields
      const marker =
        key === "content"
          ? "◉" // Big dot for content
          : key === "title"
          ? "❯" // Arrow for title
          : key === "tags"
          ? "⊛" // Star for tags
          : key === "url"
          ? "⌘" // Command symbol for URLs
          : "•"; // Default bullet

      return `${marker} ${key}: ${displayValue}`;
    })
    .join("\n\n");

  // Combine summary at the top with the rest of the content
  const fullContent = summaryContent
    ? `SUMMARY:\n${summaryContent}\n\n${content}`
    : content;

  summaryBox.setContent(
    fullContent + "\n\n" + chalk.dim("Use ↑/↓ to scroll, ESC to close")
  );

  summaryBox.show();
  summaryBox.focus();

  summaryBox.key(["escape", "z"], () => {
    summaryBox.hide();
    summaryBox.screen.render();
  });

  summaryBox.key(["up"], () => {
    summaryBox.scroll(-1);
    summaryBox.screen.render();
  });

  summaryBox.key(["down"], () => {
    summaryBox.scroll(1);
    summaryBox.screen.render();
  });

  summaryBox.screen.render();
}

export function createMapView(bookmarks) {
  const screen = blessed.screen({
    smartCSR: true,
    title: "ejfox.com/scrapbook Map View",
  });

  // Ensure we have valid terminal dimensions
  const terminalWidth = process.stdout.columns || 80;
  const terminalHeight = process.stdout.rows || 24;
  const cols = Math.min(16, Math.max(8, Math.floor(terminalWidth / 5)));

  const grid = new contrib.grid({ rows: 12, cols: cols, screen: screen });
  const mapCols = Math.max(8, cols - 4);
  const infoCols = Math.min(4, cols - mapCols);

  const map = grid.set(0, 0, 12, mapCols, contrib.map, {
    label: "Scrapbook Map",
  });

  const infoBox = grid.set(0, mapCols, 12, infoCols, blessed.box, {
    label: "Bookmark Info",
    content: "Select a marker to view bookmark info",
    scrollable: true,
    alwaysScroll: true,
    keys: true,
    vi: true,
    scrollbar: {
      ch: " ",
      inverse: true,
    },
  });

  // Filter bookmarks with location data - check top-level lat/lng fields
  const markers = bookmarks
    .filter((bookmark) => {
      // Check top-level latitude/longitude first
      if (bookmark.latitude && bookmark.longitude) {
        return true;
      }
      // Check if location field has coordinates
      if (bookmark.location) {
        try {
          const locationObj = typeof bookmark.location === 'string'
            ? JSON.parse(bookmark.location)
            : bookmark.location;
          return locationObj.latitude && locationObj.longitude;
        } catch (e) {
          return false;
        }
      }
      return false;
    })
    .map((bookmark, index) => {
      let lat, lon;

      // Get coordinates from top-level fields first
      if (bookmark.latitude && bookmark.longitude) {
        lat = bookmark.latitude;
        lon = bookmark.longitude;
      } else if (bookmark.location) {
        // Try to parse from location field
        try {
          const locationObj = typeof bookmark.location === 'string'
            ? JSON.parse(bookmark.location)
            : bookmark.location;
          lat = locationObj.latitude;
          lon = locationObj.longitude;
        } catch (e) {
          return null;
        }
      }

      return {
        lon: lon,
        lat: lat,
        color: "green",
        char: "•",
        label: bookmark.scrap_id || bookmark.id,
        bookmarkData: bookmark,
        index: index,
      };
    })
    .filter(Boolean); // Remove null entries

  // Add markers to map
  markers.forEach((marker) => map.addMarker(marker));

  // Initialize state
  let selectedMarkerIndex = markers.length > 0 ? 0 : -1;

  // Show initial info
  if (markers.length > 0) {
    showBookmarkInfo(markers[0].bookmarkData);
    infoBox.setContent(
      `Found ${markers.length} bookmarks with location data\n\n` +
      infoBox.getContent()
    );
  } else {
    infoBox.setContent(
      `No bookmarks found with location data.\n\n` +
      `Total bookmarks: ${bookmarks.length}\n` +
      `Need latitude/longitude coordinates to display on map.`
    );
  }

  function showBookmarkInfo(bookmark) {
    const rawContent = bookmark.content || bookmark.title || bookmark.url || "No content";
    const content = stripMarkdown(rawContent);
    const source = bookmark.source || "Unknown";
    const tags = formatTags(bookmark.tags);
    const location = formatLocation(bookmark.location);
    const financial = formatFinancialAnalysis(bookmark.financial_analysis);
    const relationships = formatRelationships(bookmark.relationships);

    let info = `Source: ${source}\n\n`;
    info += `Content: ${content.substring(0, 200)}${content.length > 200 ? '...' : ''}\n\n`;

    if (tags) info += `Tags: ${tags}\n\n`;
    if (location) info += `Location: ${location}\n\n`;
    if (financial) info += `Financial: ${financial}\n\n`;
    if (relationships) info += `Relationships: ${relationships}\n\n`;

    info += `Coordinates: ${bookmark.latitude}, ${bookmark.longitude}`;

    infoBox.setContent(info);
  }

  screen.key(["q", "C-c"], () => process.exit(0));
  screen.key(["up"], () => {
    if (selectedMarkerIndex > 0) {
      selectedMarkerIndex--;
      showBookmarkInfo(markers[selectedMarkerIndex].bookmarkData);
      screen.render();
    }
  });
  screen.key(["down"], () => {
    if (selectedMarkerIndex < markers.length - 1) {
      selectedMarkerIndex++;
      showBookmarkInfo(markers[selectedMarkerIndex].bookmarkData);
      screen.render();
    }
  });

  screen.render();
}

// Force layout function has been moved to ui/force-layout.js
    nodes.set(centralNodeId, {
      id: centralNodeId,
      name: focusBookmark.title || focusBookmark.content?.substring(0, 30) || centralNodeId,
      source: focusBookmark.source,
      bookmark: focusBookmark,
      x: 40, // Center it
      y: 12,
      vx: 0,
      vy: 0,
      isCentral: true
    });

    // Add relationships from the focus bookmark
    if (focusBookmark.relationships && Array.isArray(focusBookmark.relationships)) {
      focusBookmark.relationships.forEach(rel => {
        // Skip empty relationship objects
        if (!rel || typeof rel !== 'object' || Object.keys(rel).length === 0) return;

        // Handle both old and new schema formats
        const targetName = rel.target?.name || rel.target;
        const relType = rel.type || rel.relationship || 'RELATED_TO';

        // Skip if no valid target name
        if (!targetName) return;

        // Create target node
        const targetId = `node_${String(targetName).replace(/\s+/g, '_')}`;
        if (!nodes.has(targetId)) {
          nodes.set(targetId, {
            id: targetId,
            name: String(targetName),
            source: 'relationship',
            x: Math.random() * 60 + 5,
            y: Math.random() * 20 + 2,
            vx: 0,
            vy: 0
          });
        }

        links.push({
          source: centralNodeId,
          target: targetId,
          type: relType
        });
      });
    }
  } else {
    // Fallback: add all bookmarks as potential nodes (original behavior)
    bookmarks.forEach(bookmark => {
      const nodeId = bookmark.scrap_id || bookmark.id;
      if (!nodes.has(nodeId)) {
        nodes.set(nodeId, {
          id: nodeId,
          name: bookmark.title || bookmark.content?.substring(0, 30) || nodeId,
          source: bookmark.source,
          bookmark: bookmark,
          x: Math.random() * 60 + 5,
          y: Math.random() * 20 + 2,
          vx: 0,
          vy: 0
        });
      }
    });

    // Add relationships as links (original behavior)
    bookmarks.forEach(bookmark => {
      if (bookmark.relationships && Array.isArray(bookmark.relationships)) {
        bookmark.relationships.forEach(rel => {
          // Skip empty relationship objects
          if (!rel || typeof rel !== 'object' || Object.keys(rel).length === 0) return;

          const sourceId = bookmark.scrap_id || bookmark.id;
          const targetName = rel.target?.name || rel.target;
          const relType = rel.type || rel.relationship || 'RELATED_TO';

          if (!targetName) return;

          // Find or create target node
          let targetId = null;
          for (const [id, node] of nodes) {
            if (node.name.includes(targetName) || node.id === targetName) {
              targetId = id;
              break;
            }
          }

          if (!targetId) {
            targetId = `node_${String(targetName).replace(/\s+/g, '_')}`;
            nodes.set(targetId, {
              id: targetId,
              name: String(targetName),
              source: 'relationship',
              x: Math.random() * 60 + 5,
              y: Math.random() * 20 + 2,
              vx: 0,
              vy: 0
            });
          }

          links.push({
            source: sourceId,
            target: targetId,
            type: relType
          });
        });
      }
    });
  }

  const nodeArray = Array.from(nodes.values());

  let animationRunning = false;
  let selectedNodeIndex = 0;

  function renderGraph() {
    const width = graphBox.width - 2;
    const height = graphBox.height - 2;

    // Create ASCII canvas
    const canvas = Array(height).fill().map(() => Array(width).fill(' '));

    // Draw links
    links.forEach(link => {
      const sourceNode = nodes.get(link.source);
      const targetNode = nodes.get(link.target);

      if (sourceNode && targetNode) {
        drawLine(canvas,
          Math.floor(sourceNode.x), Math.floor(sourceNode.y),
          Math.floor(targetNode.x), Math.floor(targetNode.y),
          '-'
        );
      }
    });

    // Draw nodes
    nodeArray.forEach((node, index) => {
      const x = Math.floor(node.x);
      const y = Math.floor(node.y);

      if (x >= 0 && x < width && y >= 0 && y < height) {
        let char;
        if (node.isCentral) {
          char = '◆'; // Diamond for central node
        } else if (index === selectedNodeIndex) {
          char = '●'; // Filled circle for selected
        } else {
          char = '○'; // Empty circle for others
        }
        canvas[y][x] = char;

        // Add node label
        const label = node.name.substring(0, 8);
        for (let i = 0; i < label.length && x + i + 1 < width; i++) {
          canvas[y][x + i + 1] = label[i];
        }
      }
    });

    // Convert canvas to string
    const content = canvas.map(row => row.join('')).join('\n');
    graphBox.setContent(content);
  }

  function drawLine(canvas, x0, y0, x1, y1, char) {
    const dx = Math.abs(x1 - x0);
    const dy = Math.abs(y1 - y0);
    const sx = x0 < x1 ? 1 : -1;
    const sy = y0 < y1 ? 1 : -1;
    let err = dx - dy;

    let x = x0, y = y0;

    while (true) {
      if (x >= 0 && x < canvas[0].length && y >= 0 && y < canvas.length) {
        if (canvas[y][x] === ' ') canvas[y][x] = char;
      }

      if (x === x1 && y === y1) break;

      const e2 = 2 * err;
      if (e2 > -dy) { err -= dy; x += sx; }
      if (e2 < dx) { err += dx; y += sy; }
    }
  }

  function updateForces() {
    const width = graphBox.width - 2;
    const height = graphBox.height - 2;

    // Apply forces
    nodeArray.forEach(node => {
      // Center force
      const centerX = width / 2;
      const centerY = height / 2;
      node.vx += (centerX - node.x) * 0.001;
      node.vy += (centerY - node.y) * 0.001;

      // Repulsion between nodes
      nodeArray.forEach(other => {
        if (node !== other) {
          const dx = node.x - other.x;
          const dy = node.y - other.y;
          const distance = Math.sqrt(dx * dx + dy * dy) + 0.1;
          const force = 5 / (distance * distance);
          node.vx += (dx / distance) * force;
          node.vy += (dy / distance) * force;
        }
      });
    });

    // Apply link forces
    links.forEach(link => {
      const sourceNode = nodes.get(link.source);
      const targetNode = nodes.get(link.target);

      if (sourceNode && targetNode) {
        const dx = targetNode.x - sourceNode.x;
        const dy = targetNode.y - sourceNode.y;
        const distance = Math.sqrt(dx * dx + dy * dy) + 0.1;
        const targetDistance = 10;
        const force = (distance - targetDistance) * 0.1;

        const fx = (dx / distance) * force;
        const fy = (dy / distance) * force;

        sourceNode.vx += fx;
        sourceNode.vy += fy;
        targetNode.vx -= fx;
        targetNode.vy -= fy;
      }
    });

    // Update positions and apply damping
    nodeArray.forEach(node => {
      node.vx *= 0.9; // damping
      node.vy *= 0.9;

      node.x += node.vx;
      node.y += node.vy;

      // Keep within bounds
      node.x = Math.max(1, Math.min(width - 10, node.x));
      node.y = Math.max(1, Math.min(height - 2, node.y));
    });
  }

  function showNodeInfo(node) {
    let info = `Node: ${node.name}\n\n`;
    info += `Source: ${node.source}\n`;
    info += `Position: (${Math.floor(node.x)}, ${Math.floor(node.y)})\n\n`;

    if (node.bookmark) {
      const bookmark = node.bookmark;
      const rawContent = bookmark.content || bookmark.title || '';
      const cleanContent = stripMarkdown(rawContent);
      info += `Content: ${cleanContent.substring(0, 100)}\n\n`;
      if (bookmark.tags) {
        info += `Tags: ${formatTags(bookmark.tags)}\n\n`;
      }
    }

    // Show connections
    const connections = links.filter(l => l.source === node.id || l.target === node.id);
    if (connections.length > 0) {
      info += `Connections (${connections.length}): \n`;
      connections.slice(0, 5).forEach(conn => {
        const other = conn.source === node.id ? conn.target : conn.source;
        const otherNode = nodes.get(other);
        info += `  ${conn.type} ${otherNode?.name || other}\n`;
      });
      if (connections.length > 5) {
        info += `  ... and ${connections.length - 5} more\n`;
      }
    }

    infoBox.setContent(info);
  }

  // Initial render
  renderGraph();
  if (nodeArray.length > 0) {
    showNodeInfo(nodeArray[0]);
    if (focusBookmark) {
      const relationshipCount = links.length;
      infoBox.setContent(
        `Viewing relationships for:\n${focusBookmark.title?.substring(0, 50) || 'Current bookmark'}\n\n` +
        `◆ Central node\n○ Related entities\n● Selected node\n\n` +
        `Relationships: ${relationshipCount}\n\n` +
        infoBox.getContent()
      );
    }
  }

  // Animation loop
  let animationInterval;

  function startAnimation() {
    if (animationRunning) return;
    animationRunning = true;

    animationInterval = setInterval(() => {
      updateForces();
      renderGraph();
      screen.render();
    }, 100);

    infoBox.setContent(`Force simulation running...\n\nNodes: ${nodeArray.length}\nLinks: ${links.length}\n\n${infoBox.getContent()}`);
  }

  function stopAnimation() {
    if (animationInterval) {
      clearInterval(animationInterval);
      animationInterval = null;
    }
    animationRunning = false;
  }

  // Keyboard controls
  screen.key(["q", "escape"], () => {
    stopAnimation();
    screen.destroy();
    parentScreen.render();
  });

  screen.key(["f"], () => {
    if (animationRunning) {
      stopAnimation();
      infoBox.setContent(`Animation stopped\n\n${infoBox.getContent()}`);
    } else {
      startAnimation();
    }
    screen.render();
  });

  screen.key(["up"], () => {
    if (nodeArray.length > 0) {
      selectedNodeIndex = (selectedNodeIndex - 1 + nodeArray.length) % nodeArray.length;
      showNodeInfo(nodeArray[selectedNodeIndex]);
      renderGraph();
      screen.render();
    }
  });

  screen.key(["down"], () => {
    if (nodeArray.length > 0) {
      selectedNodeIndex = (selectedNodeIndex + 1) % nodeArray.length;
      showNodeInfo(nodeArray[selectedNodeIndex]);
      renderGraph();
      screen.render();
    }
  });

  screen.key(["space"], () => {
    // Randomize positions for new layout
    nodeArray.forEach(node => {
      node.x = Math.random() * (graphBox.width - 12) + 5;
      node.y = Math.random() * (graphBox.height - 4) + 2;
      node.vx = 0;
      node.vy = 0;
    });
    renderGraph();
    screen.render();
  });

  screen.render();

  // Auto-start if there are relationships
  if (links.length > 0) {
    setTimeout(startAnimation, 1000);
  } else {
    if (focusBookmark) {
      infoBox.setContent(
        `No relationships found in this bookmark.\n\n` +
        `Bookmark: ${focusBookmark.title?.substring(0, 50) || 'Current bookmark'}\n\n` +
        `This bookmark doesn't have relationship data to visualize.`
      );
    } else {
      infoBox.setContent(`No relationships found in bookmarks.\n\nTotal bookmarks: ${bookmarks.length}\n\nNeed 'relationships' field with graph data.`);
    }
  }
}
